use std::fs::File;
use std::io::{Write, Result};
use std::path::PathBuf;

use tri_mesh::Mesh;

use crate::mesh_definition;

pub fn load_obj_mesh(path: PathBuf) -> Mesh {
    // Load the mesh from a file
    let model: three_d_asset::Model = three_d_asset::io::load_and_deserialize(path).expect("Failed loading asset");
    let surface_mesh = Mesh::new(&model.geometries[0]);

    // Test if the mesh is valid
    // println!("{:?}", surface_mesh.is_valid());
    assert!(!surface_mesh.is_closed(), "Mesh is not open");

    surface_mesh
}

pub fn save_mesh_as_obj(mesh: &tri_mesh::Mesh, file_path: PathBuf) -> Result<()> {
    let mut file = File::create(file_path)?;

    // Add meta data
    writeln!(file, "# Generated by MeshCartographyLib")?;

    // Write vertices
    for vertex_id in mesh.vertex_iter() {
        let vertex = mesh.vertex_position(vertex_id);
        writeln!(file, "v {} {} {}", vertex.x, vertex.y, vertex.z)?;
    }

    // Write faces
    for face_id in mesh.face_iter() {
        let face = mesh.face_vertices(face_id);

        // OBJ indices start at 1, so we need to add 1 to each index
        let f0 = face.0.to_string().parse::<i32>().unwrap() + 1;
        let f1 = face.1.to_string().parse::<i32>().unwrap() + 1;
        let f2 = face.2.to_string().parse::<i32>().unwrap() + 1;

        writeln!(file, "f {} {} {}", f0, f1, f2)?;
    }

    Ok(())
}

pub fn save_uv_mesh_as_obj(mesh: &tri_mesh::Mesh, mesh_tex_coords: &mut mesh_definition::MeshTexCoords, file_path: PathBuf) -> Result<()> {
    let mut file = File::create(file_path)?;

    // Add meta data
    writeln!(file, "# Generated by MeshCartographyLib")?;

    // Write vertices
    for vertex_id in mesh.vertex_iter() {
        if let Some(tex_coord) = mesh_tex_coords.get_tex_coord(vertex_id) {
            writeln!(file, "v {} {} {}", tex_coord.0, tex_coord.1, 0)?;
        }
    }

    // Write faces
    for face_id in mesh.face_iter() {
        let face = mesh.face_vertices(face_id);

        // OBJ indices start at 1, so we need to add 1 to each index
        let f0 = face.0.to_string().parse::<i32>().unwrap() + 1;
        let f1 = face.1.to_string().parse::<i32>().unwrap() + 1;
        let f2 = face.2.to_string().parse::<i32>().unwrap() + 1;

        writeln!(file, "f {} {} {}", f0, f1, f2)?;
    }

    Ok(())
}
