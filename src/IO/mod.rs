use std::fs::File;
use std::io::{Write, Result};
use std::path::PathBuf;
use csv::ReaderBuilder;
use std::error::Error;
use nalgebra_sparse::{CsrMatrix, coo::CooMatrix};
use nalgebra::DMatrix;
use std::env;
use nalgebra::{Point3, Vector3};

use tri_mesh::Mesh;

use crate::mesh_definition;

pub fn load_obj_mesh(path: PathBuf) -> Mesh {
    // Load the mesh from a file
    // ! BUG: Die Reihenfolge der Vertices verÃ¤ndert sich beim Laden, sodass ich nicht die gemockten Daten verwenden kann
    let model: three_d_asset::Model = three_d_asset::io::load_and_deserialize(path).expect("Failed loading asset");
    let surface_mesh = Mesh::new(&model.geometries[0]);

    // Test if the mesh is valid
    // println!("{:?}", surface_mesh.is_valid());
    assert!(!surface_mesh.is_closed(), "Mesh is not open");

    surface_mesh
}

pub fn save_mesh_as_obj(mesh: &tri_mesh::Mesh, file_path: PathBuf) -> Result<()> {
    let mut file = File::create(file_path)?;

    // Add meta data
    writeln!(file, "# Generated by MeshCartographyLib")?;

    // Write vertices
    for vertex_id in mesh.vertex_iter() {
        let vertex = mesh.vertex_position(vertex_id);
        writeln!(file, "v {} {} {}", vertex.x, vertex.y, vertex.z)?;
    }

    // Write faces
    for face_id in mesh.face_iter() {
        let face = mesh.face_vertices(face_id);

        // OBJ indices start at 1, so we need to add 1 to each index
        let f0 = face.0.to_string().parse::<i32>().unwrap() + 1;
        let f1 = face.1.to_string().parse::<i32>().unwrap() + 1;
        let f2 = face.2.to_string().parse::<i32>().unwrap() + 1;

        writeln!(file, "f {} {} {}", f0, f1, f2)?;
    }

    Ok(())
}

// ?! Maybe this function doenst work correctly
pub fn save_uv_mesh_as_obj(mesh: &tri_mesh::Mesh, mesh_tex_coords: &mesh_definition::MeshTexCoords, file_path: PathBuf) -> Result<()> {
    let mut file = File::create(file_path)?;

    // Add meta data
    writeln!(file, "# Generated by MeshCartographyLib")?;

    // Write vertices
    for vertex_id in mesh.vertex_iter() {
        if let Some(tex_coord) = mesh_tex_coords.get_tex_coord(vertex_id) {
            writeln!(file, "v {} {} {}", tex_coord.0, tex_coord.1, 0)?;
        }
    }

    // Write faces
    for face_id in mesh.face_iter() {
        let face = mesh.face_vertices(face_id);

        // OBJ indices start at 1, so we need to add 1 to each index
        let f0 = face.0.to_string().parse::<i32>().unwrap() + 1;
        let f1 = face.1.to_string().parse::<i32>().unwrap() + 1;
        let f2 = face.2.to_string().parse::<i32>().unwrap() + 1;

        writeln!(file, "f {} {} {}", f0, f1, f2)?;
    }

    Ok(())
}

pub fn load_test_mesh() -> Mesh {
    let mesh_cartography_lib_dir_str = env::var("Meshes_Dir").expect("MeshCartographyLib_DIR not set");
    let mesh_cartography_lib_dir = PathBuf::from(mesh_cartography_lib_dir_str);
    let new_path = mesh_cartography_lib_dir.join("ellipsoid_x4_open.obj");
    load_obj_mesh(new_path)
}

pub fn load_sparse_csv_data_to_csr_matrix(file_path: &str) -> std::result::Result<CsrMatrix<f64>, Box<dyn Error>> {
    let mut reader = ReaderBuilder::new().has_headers(false).from_path(file_path)?;

    let mut row_indices = Vec::new();
    let mut col_indices = Vec::new();
    let mut values = Vec::new();
    let mut max_row_index = 0;
    let mut max_col_index = 0;

    for result in reader.records() {
        let record = result?;
        let row_index: usize = record[0].trim().parse()?;
        let col_index: usize = record[1].trim().parse()?;
        let value: f64 = record[2].trim().parse()?;

        row_indices.push(row_index - 1); // Assuming 1-based indices in CSV
        col_indices.push(col_index - 1);
        values.push(value);

        max_row_index = max_row_index.max(row_index);
        max_col_index = max_col_index.max(col_index);
    }

    // Use try_from_triplets with matrix dimensions
    // A COO Sparse matrix stores entries in coordinate-form, that is triplets (i, j, v), where i and j correspond to row and column indices of the entry, and v to the value of the entry
    let coo_matrix = CooMatrix::try_from_triplets(max_row_index, max_col_index, row_indices, col_indices, values)?;

    // Convert the CooMatrix to a CsrMatrix
    Ok(CsrMatrix::from(&coo_matrix))
}

pub fn load_csv_to_dmatrix(file_path: &str) -> std::result::Result<DMatrix<f64>, Box<dyn Error>> {
    let mut reader = ReaderBuilder::new().has_headers(false).from_path(file_path)?;

    let mut data = Vec::new();
    let mut nrows = 0;
    let mut ncols = 0;

    for result in reader.records() {
        let record = result?;
        nrows += 1;
        ncols = record.len();

        for field in record.iter() {
            let value: f64 = field.trim().parse()?;
            data.push(value);
        }
    }

    Ok(DMatrix::from_row_slice(nrows, ncols, &data))
}

pub fn load_csv_to_bool_vec(file_path: &str) -> std::result::Result<Vec<bool>, Box<dyn Error>> {
    let mut reader = ReaderBuilder::new().has_headers(false).from_path(file_path)?;

    let mut bools = Vec::new();
    for result in reader.records() {
        let record = result?;
        if let Some(field) = record.get(0) {
            let value: u8 = field.trim().parse()?;
            bools.push(value != 0);
        }
    }

    Ok(bools)
}
